---
title: mysten-metrics
description: Prometheus-based metrics for the node.
---

The `mysten-metrics` crate defines a `Metrics` struct with various `IntGaugeVec` metrics to monitor running tasks,
pending futures, channel sizes, and scope activities. A gauge is a type of metric that represents a single numerical value
that can go up or down.

```rust
#[derive(Debug)]
pub struct Metrics {
    pub tasks: IntGaugeVec,
    pub futures: IntGaugeVec,
    pub channels: IntGaugeVec,
    pub scope_iterations: IntGaugeVec,
    pub scope_duration_ns: IntGaugeVec,
    pub scope_entrance: IntGaugeVec,
}
```

These gauges are initialized as `IntGaugeVec` metrics in the `new` function of the `Metrics` struct and added to the provided `prometheus::Registry`.

```rust
impl Metrics {
    fn new(registry: &Registry) -> Self {
        Self {
            tasks: register_int_gauge_vec_with_registry!(
                "monitored_tasks",
                "Number of running tasks per callsite.",
                &["callsite"],
                registry,
            )
            .unwrap(),
            futures: register_int_gauge_vec_with_registry!(
                "monitored_futures",
                "Number of pending futures per callsite.",
                &["callsite"],
                registry,
            )
            .unwrap(),
            channels: register_int_gauge_vec_with_registry!(
                "monitored_channels",
                "Size of channels.",
                &["name"],
                registry,
            )
            .unwrap(),
            // More metrics initialized here..
        }
    }
}
```

These metrics can only be initialized and accessed using `OnceCell`, ensuring they are only initialized once and are thread-safe.
Typically, `init_metrics` is called at the beginning of the main function or in a test setup.

```rust
static METRICS: OnceCell<Metrics> = OnceCell::new();

pub fn init_metrics(registry: &Registry) {
    let _ = METRICS
        .set(Metrics::new(registry))
        // this happens many times during tests
        .tap_err(|_| warn!("init_metrics registry overwritten"));
}

pub fn get_metrics() -> Option<&'static Metrics> {
    METRICS.get()
}
```

To monitor futures and tasks in a more consistent and simple way, the crate defines multiple macros like `monitored_future!` and `spawn_monitored_task!` which wrap a given future or task, while updating their metrics.
In order for the macros to update the metrics, they call the global `get_metrics` function to retrieve the `Metrics` struct to update the corresponding gauges.

To monitor code scops, the `monitored_scope` function can create a named scope, that keeps track of
- the total iterations where the scope is called in the `monitored_scope_iterations` metric
- and the total duration of the scope in the `monitored_scope_duration_ns` metric

with the total duration of the scope being updated when the scope is dropped:

```rust
impl Drop for MonitoredScopeGuard {
    fn drop(&mut self) {
        self.metrics
            .scope_duration_ns
            .with_label_values(&[self.name])
            .add(self.timer.elapsed().as_nanos() as i64);
        self.metrics
            .scope_entrance
            .with_label_values(&[self.name])
            .dec();
    }
}
```

Monitored scopes are used in multiple parts of the node. For example, the `consensus_handler` module uses monitored scopes to track the duration and number of iterations of
the `handle_consensus_output` function:

```rust
    async fn handle_consensus_output(&mut self, consensus_output: ConsensusOutput) {
    let _scope = monitored_scope("HandleConsensusOutput");
    self.handle_consensus_output_internal(consensus_output)
        .await;
}
```

## `RegistryService`

The `RegistryService` manages multiple Prometheus registries.

```rust

/// A service to manage the prometheus registries. This service allow us to
/// create a new Registry on demand and keep it accessible for
/// processing/polling.
#[derive(Clone)]
pub struct RegistryService {
    // Holds a Registry that is supposed to be used
    default_registry: Registry,
    registries_by_id: Arc<DashMap<Uuid, Registry>>,
}
```

It allows for the creation, addition, and removal of these Prometheus registries.
By using a default registry and a collection of additional registries identified by unique UUIDs, it ensures that
metrics can be organized. The service can gather metrics from all registries, making it easy to retrieve data.
It supports thread-safe operations and can be cloned and shared across different parts of the node.
