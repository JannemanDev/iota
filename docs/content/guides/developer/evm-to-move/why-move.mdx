---
title: Why Move?
---

While EVM/Solidity is the biggest right now when it comes to Smart Contract development, it definitely has some less desired properties, amongst which:

 - **Performance, scaling and cost**: EVM builds on top of a global shared state, something that is practical but doesn't scale well. This results in limitations in throughput which is directly reflected in the fees you need to pay to interact with these networks. The more congested the more expensive it gets. This is worked around with additional extra execution layers (L2's on top of L1's) or rollup solutions, which have their own downsides and limitations as well.
 - **Security:** As the first well-used smart contract language Solidity did not have a lot to go by in terms of learnings around secure practices (there was no existing ecosystem yet) and it had to develop over years with that legacy and backwards compatibility in mind. Many of the issues from the past have been mitigated with workarounds but given the nature of things there are some limitations and annoyances we currently can't get around like the security issues it has with both the code and infamous design patterns like the `approve()` method in the ERC standards.
 - **Tokens:** Assets like ERC20 tokens and ERC721/1155 NFTs are not part of the EVM and are purely standards for smart contracts deployed on a EVM chain that are interpreted as tokens by clients. While this works and allows a lot of flexibility it also has its downsides. Due to the nature of tokens being contracts and the state of your balance being stored with those contracts it's not trivial to find all tokens in your account without knowing all token contract addresses and manually adding them; Unlike the Ethereum balance itself which is a different kind of token which can be found directly but works differently over a ERC20 token. This makes discovery of your own assets difficult and adds additional complexity to applications to close the gap between the native asset (ETH) and ERC20 tokens with workarounds like wrapped tokens; Not ideal.
 - **Developer experience:** While Solidity is not so hard to get started with (the language is influenced by popular and well known languages like C++ and Javascript) it's notoriously hard to write safe code for it; On the other hand it's quite easy to write something that works at a first glance making this a dangerous property resulting in billions lost in the ecosystem due to coding mistakes and a lot of money spent on audits by expensive external parties that don't give any guarantee about the code actually being safe after the audit has passed. Due to this and other factors like the strange quirks in Solidity, the limited implementation of static-typing and too much abstraction to libraries Solidity has gained a reputation of being a bit of a minefield to work with - where the status quo is copying code that has been battle tested over true innovation. There are not a lot of developers that enjoy writing Solidity and the fear to make a mistake is often quite high, especially when there's big value at stake. 

IOTA Move is here to learn from these downsides, and come up with a better alternative addressing these issues:

* **Performance, scaling and cost:** Given IOTA Move is based on the object model (similar to UTXO's) and not a globally shared state transactions can be executed in parallel resulting in a much higher (potential) throughput over a traditional blockchain with shared state. This results in a lot less congestion and thus lower fees on an actively used network. 
* **Security:** Move was designed with security in mind. The language itself is based on Rust and is very strict when it comes to it's typing system, you really have to try to make a microsake that the compiler won't catch for you before deploying. There's no such thing as re-entry and given the object based approach of Move Assets residing in your account can't be touched at all by the smart contract itself without access to your accounts keys. 
* **Tokens:** In IOTA Move there is no difference between the IOTA token (`Coin<IOTA>`) and a custom token (`Coin<YOUR_NAME_HERE>`), not in terms of use or implementation. These objects reside in your own account and can thus easily be found without needing to know a Smart Contract address (this goes for any other type of owned object as well). There's no strange `approve()` functionality and you keep the control over your own owned assets.
* **Developer Experience:** While Move is harder to get started with over Solidity; The safety of the language and excellent developer experience when it comes to finding issues in your code and resolving them make up for that. With Move it's not so scary any more to write complex logic from scratch given most mistakes (apart from obvious implementation logic, doing things 'as intended') are caught directly by the compiler. This allows for more innovation, less value-destroying bugs and overall a nicer developer experience which will fuel the next generation of smart contracts.


To sum this up:

| EVM/Solidity                               | Move                                                   |
| ------------------------------------------ | ------------------------------------------------------ |
| State as part of contracts                 | State as objects                                       |
| Global shared state                        | Owned and Shared objects                               |
| Transactions executed one by one           | Parallel execution                                     |
| No enforced security for standards         | Strict type system for standards, assurances           |
| Easy to get started with, hard to do right | Harder to get started with, but less room for mistakes |

